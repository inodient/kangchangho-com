module.exports.getPool = getPool;
module.exports.getConnection = getConnection;
module.exports.executeQuery = executeQuery;
module.exports.releasePool = releasePool;
module.exports.releaseConnection = releaseConnection;
module.exports.getQueries = getQueries;





const mysql = require( "mysql" );
const queries = require( __mysqlQueries );




function getPool(){
	return new Promise( function(resolve, reject){
		try{
			resolve( mysql.createPool( require(__mysqlHandlerInfo) ) );
		} catch( err ){
			reject( err );
		}
	} );
}

function getConnection(){
	var _pool = undefined;

	if( arguments ){
		_pool = arguments[0];
	}

	return new Promise( function(resolve, reject){

		if( _pool ){
			_pool.getConnection( function(err, _connection){
				if( err ) reject( err );
				resolve( _connection );
			} );

		} else{
			getPool()
			.then( function(_pool){
				_pool.getConnection( function(err, _connection){
					if( err ) reject( err );
					resolve( _connection );
				} );
			} );
		}
	} );
}






function executeQuery( queryId ){
	var params = undefined;
	var connection = undefined;

	if( arguments[1] && typeof arguments[1] == "object" ){
		if( arguments[1] instanceof Array ){
			params = arguments[1];

			if( arguments[2] ){
				connection = arguments[2];
			}
		} else if( !(arguments[1] instanceof Array) ){
			connection = arguments[1];
		}
	}

	return new Promise( function(resolve, reject){
		if( connection ){
			executeTransaction( queryId, params, connection )
			.then( function(queryResults){
				resolve( queryResults );
			} )
			.catch( function(err){
				reject( err );
			} );
		} else{
			getConnection()
			.then( executeTransaction.bind(null, queryId, params) )
			.then( function(queryResults){
				releaseConnection( queryResults.connection );
				releasePool( queryResults.connection.config.pool );

				resolve( queryResults );
			} )
			.catch( function(err){
				reject( err );
			} );
		}
	} );
}

function executeTransaction( queryId, params, connection ){

	return new Promise( function(resolve, reject){
		try{
			connection.beginTransaction( function(err){
				if( err ){
					reject( err );
				}

				connection.query( getQueryString( queryId, params ), params, function(err, results, fields){

					if( err ){
						connection.rollback( function(){
							reject( err );
						} );
					}

					connection.commit( function(err){
						if( err ){
							connection.rollback( function(){
								reject( err );
							} )
						}

						resolve( { connection:connection, results:results, fields:fields } );
					});

				} );
			} );
		} catch( err ){
			reject( err );
		}
	} );
}






function releasePool( pool ){
	pool.end();
}

function releaseConnection( _connection ){
	_connection.destroy();
}

function getQueryString( queryId, params ){

	if( queriesXML ){
		let queriesArr = queriesXML.queries.query;

		for( var i=0; i<queriesArr.length; i++ ){
			if( queriesArr[i].$.id == queryId ){
				return setQueryParams( queriesArr[i]._, params );
			}
		}
	}

	for( var i=0; i<queries.length; i++ ){
		if( queries[i].id == queryId ){
			return queries[i].queryString;
		}
	}

	return "SELECT NOW()";
}

function setQueryParams( queryString, params ){

	for( var i=0; i<params.length; i++ ){
		if( params[i] instanceof Object ){
			var key = Object.keys( params[i] )[0];
			var value = ( params[i] )[key];

			if( !isNaN(parseFloat(value)) && isFinite(value) ){
				queryString = queryString.replace( new RegExp("#" + key + "#", "gi"), value );
			} else {
				queryString = queryString.replace( new RegExp("#" + key + "#", "gi"), "'" + value + "'" );
			}
		}
	}

	return queryString;
}




function getQueries(){
	return new Promise( function(resolve, reject){
		var fs = require('fs'), xml2js = require('xml2js');
		var parser = new xml2js.Parser();

		fs.readFile( __mysqlQueriesXML, function(err, data) {
			parser.parseString(data, function (err, result) {
				resolve( result );
			});
		});
	} );
}
